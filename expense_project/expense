#! /usr/bin/env ruby
# frozen_string_literal: true

require 'pg'

# Communicates requests to the database.
class ExpenseData
  def initialize
    @connection = PG.connect(dbname: 'expenses')
  end

  def list_expenses
    result = connection.exec 'SELECT * FROM expenses ORDER BY created_on ASC;'

    result.each do |tuple|
      columns = [tuple['id'].rjust(3),
                 tuple['created_on'].rjust(10),
                 tuple['amount'].rjust(12),
                 tuple['memo']]

      puts columns.join(' | ')
    end
  end

  def add_expense(amount, memo)
    date = Date.today
    sql = <<~INSERTION

      INSERT INTO expenses (amount, memo, created_on)
        VALUES ($1, $2, $3);

    INSERTION

    connection.exec_params sql, [amount, memo, date]
  end

  def display_help
    puts <<~HELP
      An expense recording system

      Commands:

      add AMOUNT MEMO [DATE] - record a new expense
      clear - delete all expenses
      list - list all expenses
      delete NUMBER - remove expense with id NUMBER
      search QUERY - list expenses with a matching memo field
    HELP
  end

  private

  attr_accessor :connection
end

# Communicates with the client and relays requests to ExpenseData
class CLI
  def initialize
    @expenses = ExpenseData.new
  end

  def run(args)
    @args = args

    validate_arguments
    execute
  end

  def validate_arguments
    return unless (args[0] == 'add') &&
                  (args.size != 3 || args[1].to_f.to_s != args[1])

    raise ArgumentError,
          'You must provide an amount (integer) and memo, in that order.'
  end

  def execute
    case args[0]
    when 'list' then expenses.list_expenses
    when 'add'  then expenses.add_expense(args[1], args[2])
    else             expenses.display_help
    end
  end

  private

  attr_reader :args, :expenses
end

connection = CLI.new
connection.run(ARGV)
